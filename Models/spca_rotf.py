# -*- coding: utf-8 -*-
"""SPCA-RotF.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1PM3iP4GjKjEgskNjsPPlJI5yDb3_23me
"""

import pandas as pd
import numpy as np

from sklearn.decomposition import MiniBatchSparsePCA
from sklearn.tree import DecisionTreeRegressor
from sklearn.model_selection import train_test_split

def get_random_subset(iterable,k):
    subsets = []
    iteration = 0
    np.random.shuffle(iterable)
    subset = 0
    limit = len(iterable)/k
    while iteration < limit:
        if k <= len(iterable):
            subset = k
        else:
            subset = len(iterable)
        subsets.append(iterable[-subset:])
        del iterable[-subset:]
        iteration+=1
    return subsets

def Rotation_Forest_SPCA(X , Y, test_x, max_depth, size, n_trees, k,batch , iter ):
  r_matrices , models = [],[]

  for tree in range(n_trees):
    feature_index = list(range(X.shape[1]))
    k_subset = get_random_subset(feature_index,k) #每個子集有k個特徵，每個子集特徵不重複 #將訓練集中的屬性拆分為大小相等的 K 個非重疊子集。
    rotation_matrix = np.zeros((X.shape[1],X.shape[1]),dtype=float) #591*591大小的矩陣

    for each_subset in k_subset:
      pca = MiniBatchSparsePCA(batch_size = batch ,n_iter = iter )
      X_train, X_test, y_train, y_test = train_test_split(X, Y, train_size = size)
      X_subset = X_train.iloc[:,each_subset]
      pca.fit(X_subset)
      for i in range(0,len(pca.components_)):
        for j in range(0,len(pca.components_)):
          rotation_matrix[each_subset[i],each_subset[j]] = pca.components_[i,j]

    x_transformed = X.dot(rotation_matrix)
    model = DecisionTreeRegressor(max_depth = max_depth)
    model.fit(x_transformed,Y)
    models.append(model) #存放每個樹的模型
    r_matrices.append(rotation_matrix) #存放每個樹的旋轉矩陣

  return models,r_matrices

def model_predict(models,r_matrices,x):
    predicted_ys = []
    for i,model in enumerate(models):
        x_mod =  x.dot(r_matrices[i])
        predicted_y = model.predict(x_mod)
        predicted_ys.append(predicted_y)

    final_results = []
    for i in range(len(predicted_ys[0])): #總共要預測的Y有幾個 #2000個預測值
        predict_result = [] #存放每棵樹的預測值 #100棵樹有100個預測值
        for j in range(len(predicted_ys)): #每棵樹的預測值 #100棵樹
            predict_result.append( (predicted_ys[j][i]) )
        final_results.append(np.mean(predict_result))

    return final_results