# -*- coding: utf-8 -*-
"""SPCA-TWRotF.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1BfdS8N_oM95wcEHAZNN0ShvKTyyFeM9O
"""

import pandas as pd
import numpy as np

from sklearn.decomposition import MiniBatchSparsePCA
from sklearn.tree import DecisionTreeRegressor
from sklearn.model_selection import train_test_split

def get_random_subset(iterable,k):
    subsets = []
    iteration = 0
    np.random.shuffle(iterable)
    subset = 0
    limit = len(iterable)/k
    while iteration < limit:
        if k <= len(iterable):
            subset = k
        else:
            subset = len(iterable)
        subsets.append(iterable[-subset:])
        del iterable[-subset:]
        iteration+=1
    return subsets

def weighted_average(prediction_set,oobrmse):
    final_results = []
    for i in range(len(prediction_set[0])): #總共要預測的Y有幾個 #2000個預測值
        predict_result = [] #存放每棵樹的預測值 #100棵樹有100個預測值
        final_result = 0
        for j in range(len(prediction_set)): #每棵樹的預測值 #100棵樹
            predict_result.append( (prediction_set[j][i]) )

        for k in range(len(predict_result)): #加權預測值
            final_result =  final_result + predict_result[k] * oobrmse[k]
        final_results.append(final_result)
    return final_results

def Tree_Weighting_Rotation_Forest_SPCA(X , Y, test_x, max_depth, size, n_trees, k, batch, iter):
    strength_set = []
    Prediction_set = []
    OOB_MSE = []
    r_matrices , models = [],[]
    for tree in range(n_trees):
        feature_index = list(range(X.shape[1]))
        k_subset = get_random_subset(feature_index,k) #每個子集有k個特徵，每個子集特徵不重複 #將訓練集中的屬性拆分為大小相等的 K 個非重疊子集。
        rotation_matrix = np.zeros((X.shape[1],X.shape[1]),dtype=float) #591*591大小的矩陣
        X_train, X_valid, y_train, y_valid = train_test_split(X, Y, train_size = size)

        for each_subset in k_subset:
            pca = MiniBatchSparsePCA(batch_size = batch ,n_iter = iter )
            x_train,_,_,_ = train_test_split(X_train, y_train, train_size = 0.7)
            X_subset = x_train.iloc[:,each_subset]
            pca.fit(X_subset)
            for i in range(0,len(pca.components_)):
                for j in range(0,len(pca.components_)):
                    rotation_matrix[ each_subset[i],each_subset[j] ] = pca.components_[i,j]

        x_transformed = X_train.dot(rotation_matrix)
        model = DecisionTreeRegressor(max_depth = max_depth).fit(x_transformed,y_train)

        x_valid_transformed = X_valid.dot(rotation_matrix)
        valid_prediction = model.predict(x_valid_transformed)

        models.append(model) #存放每個樹的模型
        r_matrices.append(rotation_matrix) #存放每個樹的旋轉矩陣

        OOB_MSE.append(mean_squared_error(y_valid,valid_prediction) )

    oob_mse_prop = OOB_MSE/np.sum(OOB_MSE)

    predicted_ys = [] #測試階段預測
    for i,model in enumerate(models):
        x_mod =  test_x.dot(r_matrices[i])
        predicted_y = model.predict(x_mod)
        predicted_ys.append(predicted_y)

    weighted_result = weighted_average(predicted_ys,oob_mse_prop)
    return weighted_result